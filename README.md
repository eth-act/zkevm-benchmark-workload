<p align="center">
  <img src="assets/logo-white-transparent-bg.png" alt="ZK-EVM Bench" width="300"/>
</p>

<h1 align="center">zkEVM Benchmarking Workload</h1>

This workspace contains code for executing Ethereum block validation logic within different Zero-Knowledge Virtual Machines (zkVMs) where the input is generated by the [execution spec tests](https://github.com/ethereum/execution-spec-tests).

## Goal

The primary goal is to measure and compare the performance (currently in cycle counts) of running a standardized benchmarking workload (including known worse-cases) with the same stateless validation logic* across various zkVM platforms.

*We cannot guarantee the logic will be the same for targets that are not supported by the Rust toolchain. An example of this currently is Cairo.

## Workspace Structure

The workspace is organized into several key components:

- **`crates/metrics`**: Defines common data structures (`WorkloadMetrics`) for storing and serializing benchmark results.
- **`crates/witness-generator`**: A library that provides functionality for generating benchmark fixture files (`BlockAndWitness`: individual block + witness pairs) required for stateless block validation by processing standard Ethereum test fixtures or RPC endpoints.
- **`crates/witness-generator-cli`**: A standalone binary that uses the `witness-generator` library to generate fixture files. These are saved in the `zkevm-fixtures-input` folder. The crate includes Docker support for containerized deployment.
- **`crates/ere-hosts`**: A standalone binary that runs benchmarks across different zkVM platforms using pre-generated fixture files from `zkevm-fixtures-input`.
- **`crates/benchmark-runner`**: Provides utilities for running benchmarks across different zkVM implementations.
- **`crates/zkevm-zkm`**: Contains the zkMIPS-specific implementation.
- **`ere-guests/`**: Directory containing guest program implementations for different zkVM platforms:
  - `ere-guests/sp1/`: Succinct SP1 guest implementation
  - `ere-guests/openvm/`: OpenVM guest implementation  
  - `ere-guests/risc0/`: RISC0 guest implementation
  - `ere-guests/zkm/`: zkMIPS guest implementation
  - `ere-guests/pico/`: Pico guest implementation
- **`zkevm-fixtures`**: (Git submodule) Contains the Ethereum execution layer test fixtures used by `witness-generator-cli`.
- **`zkevm-fixtures-input`**: Default directory where `witness-generator-cli` saves individual fixture files (`.json`) that are consumed by `ere-hosts`.
- **`zkevm-metrics`**: Directory where benchmark results (cycle counts) are stored by the host programs, organized by zkVM type.
- **`scripts`**: Contains helper scripts (e.g., fetching fixtures).
- **`xtask`**: Cargo xtask runner for automating tasks.

## Workflow Overview

The benchmarking process is decoupled into two distinct phases:

1. **Fixture Generation** (`witness-generator-cli`): Processes Ethereum test fixtures (EEST) or RPC data to generate individual `BlockAndWitness` fixtures as JSON files saved in `zkevm-fixtures-input/`.
2. **Benchmark Execution** (`ere-hosts`): Reads from `zkevm-fixtures-input/` and runs performance benchmarks across different zkVM platforms.

This decoupling provides several benefits:
- Independent fixture generation and benchmark execution
- Reuse of generated fixtures across multiple benchmark runs

## Core Concepts

Each zkVM benchmark implementation follows a common pattern:

1. **Guest Program:**
    - Located within the `ere-guests/` directory for the specific zkVM (e.g., `ere-guests/sp1/`, `ere-guests/openvm/`).
    - Contains the Rust code that executes the Ethereum state transition function(`reth_stateless::validation::stateless_validation`).
    - This code is compiled specifically for the target zkVM's architecture (e.g., RISC-V for SP1, MIPS for zkMIPS).
    - It reads block/witness data from its zkVM environment's standard input.
    - Uses platform-specific mechanisms (often `println!` markers) to delineate code regions for cycle counting.

2. **Host Program:**
    - Located within `crates/ere-hosts/` with shared host logic across zkVM platforms.
    - A standalone Rust binary that orchestrates the benchmarking.
    - Consumes pre-generated fixture files from `crates/witness-generator-cli`.
    - Invokes the corresponding zkVM SDK to execute the compiled Guest program ELF with the necessary inputs.
    - Collects cycle count metrics reported by the zkVM SDK.
    - Saves the results using the `metrics` crate into the appropriate subdirectory within `zkevm-metrics/`.

3. **Automatic Patch Application:**
    - The benchmark runner includes functionality to automatically apply precompile patches for each zkVM.

## Prerequisites

1. **Rust Toolchain:** A standard Rust installation managed by `rustup`.
2. **zkVM-Specific Toolchains:** Each zkVM requires its own SDK and potentially a custom Rust toolchain/target. Please refer to the specific zkVM guest directory in `ere-guests/` (e.g., `ere-guests/sp1/README.md`, `ere-guests/openvm/README.md`) for detailed setup instructions for that platform.
3. **Git:** Required for cloning the repository :)
4. **Common Shell Utilities:** The scripts in the `./scripts` directory require a `bash`-compatible shell and standard utilities like `curl`, `jq`, and `tar`.

## Setup

1. **Clone the Repository:**

    ```bash
    git clone <repository-url>
    cd zkevm-benchmark-workload
    ```

2. **Fetch/Update Benchmark Fixtures:**

    ```bash
    ./scripts/download-and-extract-fixtures.sh
    ```

3. **Generate Benchmark Input Files:**

    Navigate to `crates/witness-generator-cli/` and generate fixture files:

    ```bash
    cd crates/witness-generator-cli
    cargo run --release -- tests --include Prague --include cold
    
    # Or generate from local EEST fixtures
    cargo run --release -- tests --eest-fixtures-path /path/to/local/eest/fixtures
    
    # Or generate from RPC
    cargo run --release -- rpc --last-n-blocks 2 --rpc-url <your-rpc-url>
    
    # Or listen for new blocks continuously
    cargo run --release -- rpc --follow --rpc-url <your-rpc-url>
    ```

    This creates individual `.json` files in the `zkevm-fixtures-input/` directory that will be consumed by the benchmark runner.

4. **(Optionally) Patching Precompiles**: Each zkVM, for efficiency purposes requires particular dependencies to be patched.
This repository contains an `xtask` that will automate this process by calling `cargo <zkvm-name>`. See `.config/cargo.toml` for how this is setup and `precompile-patches` for the patches that each zkVM requires.

> Note: This is optional as it should be automatically done when the benchmarks are ran.

5. **Run Benchmarks:**

    Navigate to `crates/ere-hosts/` and run benchmarks using the generated fixture files:

    ```bash
    cd crates/ere-hosts
    cargo run --release --features sp1
    cargo run --release --features "sp1,risc0"
    ```

    See the respective README files in each crate for detailed usage instructions.

## Supported zkVM Benchmarks

| zkVM             | Guest Path            | Host Path           | Metrics Output             |
| ---------------- | --------------------- | ------------------- | -------------------------- |
| **Succinct SP1** | `ere-guests/sp1/`     | `crates/ere-hosts/` | `zkevm-metrics/sp1/`       |
| **RISC0**        | `ere-guests/risc0/`   | `crates/ere-hosts/` | `zkevm-metrics/risc0/`     |
| **OpenVM**       | `ere-guests/openvm/`  | `crates/ere-hosts/` | `zkevm-metrics/openvm/`    |
| **Pico**         | `ere-guests/pico/`    | `crates/ere-hosts/` | `zkevm-metrics/pico/`      |
| **Zisk**         | `ere-guests/zisk/`    | `crates/ere-hosts/` | `zkevm-metrics/zisk/`      |

## CI/CD and Docker Support

The repository includes automated Docker image building through GitHub Actions:

- **Automated Builds**: Docker images are automatically built and pushed to GitHub Container Registry (`ghcr.io`) on pushes to the master branch
- **Manual Builds**: Docker builds can be triggered manually via GitHub Actions workflow dispatch  
- **Container Registry**: Pre-built images are available at `ghcr.io/<repository>/witness-generator-cli`
- **Multi-platform Support**: Images are built for multiple architectures and cached for efficient builds

The Docker workflow (`.github/workflows/docker-build.yml`) provides:
- Automatic tagging with git SHA and `latest` for the default branch
- Docker layer caching for faster subsequent builds
- Integration with GitHub's container registry with proper authentication

The Docker image provides a self-contained environment for running the witness generator without local Rust toolchain setup.
